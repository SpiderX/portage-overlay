From 751b0d313c25ac03d57f475c8aafa1fca6005785 Mon Sep 17 00:00:00 2001
From: David Beazley <dave@dabeaz.com>
Date: Wed, 10 Apr 2024 10:08:03 -0500
Subject: [PATCH] Removed subprocess

---
 CHANGES                                       |  23 +++
 curio/kernel.py                               |   2 +-
 curio/monitor.py                              | 100 ++++--------
 .../curio_subprocess.py                       |  16 +-
 tests/test_subprocess.py                      | 142 ------------------
 tests/test_thread.py                          |  17 ---
 6 files changed, 61 insertions(+), 239 deletions(-)
 rename curio/subprocess.py => examples/curio_subprocess.py (95%)
 delete mode 100644 tests/test_subprocess.py

diff --git a/CHANGES b/CHANGES
index 7922b841..30b16092 100644
--- a/CHANGES
+++ b/CHANGES
@@ -1,5 +1,28 @@
 CHANGES
 -------
+April 10, 2024: Note: I've decided to take Curio in a different
+direction.  Initially, Curio was developed with variety of
+"experimental" features with the expectation that people might play
+around with them and we'd learn together.  However, this never really
+materialized.  As such, I'm going to be trimming the feature set.  If
+this affects you, please look at the "examples" directory because I
+may have moved code there.  Many features of Curio were simply
+higher-level modules implemented on top of an existing core and can be
+added back to your code without much effort. -- Dave
+
+04/10/2024 Removed subprocess module.  Use the Python built-in instead.
+           Old code found in examples/curio_subprocess.py
+	   
+04/10/2024 Removed dependency on telnetlib.  Removed commands from the
+           monitor that allowed changes to the running environment,
+	   specifically the `cancel` and `signal` commands.  It's
+	   not clear that cancelling tasks from the monitor would
+	   be all that useful to begin with.  If you need to send
+	   a Unix signal, use `kill` at the command line.
+	  
+04/10/2024 Eliminated flaky tests that were already marked for
+           skipping in pytest.
+
 Version 1.6 - October 25, 2022
 ------------------------------
 
diff --git a/curio/kernel.py b/curio/kernel.py
index a4b633f7..32346eed 100644
--- a/curio/kernel.py
+++ b/curio/kernel.py
@@ -817,8 +817,8 @@ def run(corofunc, *args, with_monitor=False, selector=None,
     if with_monitor or 'CURIOMONITOR' in os.environ:
         from .monitor import Monitor
         m = Monitor(kernel)
+        m.start()
         kernel._call_at_shutdown(m.close)
-        kernel.run(m.start)
 
     with kernel:
         return kernel.run(corofunc, *args)
diff --git a/curio/monitor.py b/curio/monitor.py
index 0d76c5de..71bdd4dc 100644
--- a/curio/monitor.py
+++ b/curio/monitor.py
@@ -25,37 +25,28 @@
 # Where host and port configure the network address on which the monitor
 # operates.
 #
-# To connect to the monitor, run python3 -m curio.monitor -H [host] -p [port]. For example:
+# To connect to the monitor, run python3 -m curio.monitor -H [host] -p [port]. 
 #
 # Theory of operation:
 # --------------------
 # The monitor works by opening up a loopback socket on the local
-# machine and allowing connections via telnet. By default, it only
-# allows a connection originating from the local machine.  Only a
-# single monitor connection is allowed at any given time.
+# machine and allowing connections via a tool like telnet or nc.  By
+# default, it only allows a connection originating from the local
+# machine.  Only a single monitor connection is allowed at any given
+# time.
 #
-# There are two parts to the monitor itself: a user interface and an
-# internal loop that runs on curio itself.  The user interface part
-# runs in a completely separate execution thread.  The reason for this
-# is that it allows curio to be monitored even if the curio kernel is
-# completely deadlocked, occupied with a large CPU-bound task, or
-# otherwise hosed in the some way.  At a minimum, you can connect,
-# look at the task table, and see what the tasks are doing.
-#
-# The internal monitor loop implemented on curio itself is presently
-# used to implement external task cancellation.  Manipulating any part
-# of the kernel state or task status is unsafe from an outside thread.
-# To make it safe, the user-interface thread of the monitor hands over
-# requests requiring the involvement of the kernel to the monitor
-# loop.  Since this loop runs on curio, it can safely make
-# cancellation requests and perform other kernel-related actions.
+# The monitor is implemented externally to Curio using threads.  The
+# reason for this is that it allows curio to be monitored even if the
+# curio kernel is completely deadlocked, occupied with a large
+# CPU-bound task, or otherwise hosed in the some way.  At a minimum,
+# you can connect, look at the task table, and see what the tasks are
+# doing.
 
 import os
 import signal
 import time
 import socket
 import threading
-import telnetlib
 import argparse
 import logging
 import sys
@@ -121,7 +112,6 @@ class Monitor(object):
     def __init__(self, kern, host=MONITOR_HOST, port=MONITOR_PORT):
         self.kernel = kern
         self.address = (host, port)
-        self.monitor_queue = queue.UniversalQueue()
         self._closing = None
         self._ui_thread = None
 
@@ -131,27 +121,14 @@ def close(self):
         if self._ui_thread:
             self._ui_thread.join()
 
-    async def monitor_task(self):
-        '''
-        Asynchronous task loop for carrying out task cancellation.
-        '''
-        while True:
-            task = await self.monitor_queue.get()
-            await task.cancel()
-
-    async def start(self):
+    def start(self):
         '''
         Function to start the monitor
         '''
-        # The monitor launches both a separate thread and helper task
-        # that runs inside curio itself to manage cancellation events
-
         log.info('Starting Curio monitor at %s', self.address)
-
+        self._closing = threading.Event()        
         self._ui_thread = threading.Thread(target=self.server, args=(), daemon=True)
-        self._closing = threading.Event()
         self._ui_thread.start()
-        await spawn(self.monitor_task, daemon=True)
 
     def server(self):
         '''
@@ -159,7 +136,7 @@ def server(self):
         from curio itself.
         '''
         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
-        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
+        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, True)
 
         # set the timeout to prevent the server loop from
         # blocking indefinitaly on sock.accept()
@@ -172,7 +149,6 @@ def server(self):
                     client, addr = sock.accept()
                     with client:
                         client.settimeout(0.5)
-
                         # This bit of magic is for reading lines of input while still allowing timeouts
                         # and the ability for the monitor to die when curio exits.  See Issue #108.
                         def readlines():
@@ -193,6 +169,7 @@ def readlines():
 
                         sout = client.makefile('w', encoding='latin-1')
                         self.interactive_loop(sout, readlines())
+                        sout.close()
                 except socket.timeout:
                     continue
 
@@ -224,14 +201,6 @@ def interactive_loop(self, sout, input_lines):
                     self.command_exit(sout)
                     return
 
-                elif resp.startswith('cancel'):
-                    _, taskid_s = resp.split()
-                    self.command_cancel(sout, int(taskid_s))
-
-                elif resp.startswith('signal'):
-                    _, signame = resp.split()
-                    self.command_signal(sout, signame)
-
                 elif resp.startswith('w'):
                     _, taskid_s = resp.split()
                     self.command_where(sout, int(taskid_s))
@@ -248,8 +217,6 @@ def command_help(self, sout):
             '''Commands:
          ps               : Show task table
          where taskid     : Show stack frames for a task
-         cancel taskid    : Cancel an indicated task
-         signal signame   : Send a Unix signal
          parents taskid   : List task parents
          quit             : Leave the monitor
 ''')
@@ -260,18 +227,6 @@ def command_ps(self, sout):
     def command_where(self, sout, taskid):
         where(taskid, self.kernel, sout)
 
-    def command_signal(self, sout, signame):
-        if hasattr(signal, signame):
-            os.kill(os.getpid(), getattr(signal, signame))
-        else:
-            sout.write('Unknown signal %s\n' % signame)
-
-    def command_cancel(self, sout, taskid):
-        task = self.kernel._tasks.get(taskid)
-        if task:
-            sout.write('Cancelling task %d\n' % taskid)
-            self.monitor_queue.put(task)
-
     def command_parents(self, sout, taskid):
         while taskid:
             task = self.kernel._tasks.get(taskid)
@@ -282,22 +237,25 @@ def command_parents(self, sout, taskid):
                 break
 
     def command_exit(self, sout):
-        sout.write('Leaving monitor. Hit Ctrl-C to exit\n')
+        sout.write('Leaving monitor.\n')
         sout.flush()
 
 def monitor_client(host, port):
     '''
-    Client to connect to the monitor via "telnet"
+    Client to connect to the monitor via a socket
     '''
-    tn = telnetlib.Telnet()
-    tn.open(host, port, timeout=0.5)
-    try:
-        tn.interact()
-    except KeyboardInterrupt:
-        pass
-    finally:
-        tn.close()
-
+    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    sock.connect((host, port))
+    def display(sock):
+        while (chunk := sock.recv(1000)):
+            sys.stdout.write(chunk.decode('utf-8'))
+            sys.stdout.flush()
+        os._exit(0)
+    threading.Thread(target=display, args=[sock], daemon=True).start()
+    while True:
+        line = sys.stdin.readline()
+        sock.sendall(line.encode('utf-8'))
+    sock.close()
 
 def main():
     parser = argparse.ArgumentParser("usage: python -m curio.monitor [options]")
diff --git a/curio/subprocess.py b/examples/curio_subprocess.py
similarity index 95%
rename from curio/subprocess.py
rename to examples/curio_subprocess.py
index 1b814f93..c5f18543 100644
--- a/curio/subprocess.py
+++ b/examples/curio_subprocess.py
@@ -1,4 +1,4 @@
-# curio/subprocess.py
+# curio_subprocess.py
 #
 # A curio-compatible standin for the subprocess module.  Provides
 # asynchronous compatible versions of Popen(), check_output(),
@@ -24,15 +24,15 @@
 
 # -- Curio
 
-from .task import spawn
-from .time import sleep
-from .errors import CancelledError
-from .io import FileStream
-from . import thread
-from .workers import run_in_thread
+from curio.task import spawn
+from curio.time import sleep
+from curio.errors import CancelledError
+from curio.io import FileStream
+from curio import thread
+from curio.workers import run_in_thread
 
 if sys.platform.startswith('win'):
-    from .file import AsyncFile as FileStream
+    from curio.file import AsyncFile as FileStream
 
 class Popen(object):
     '''
diff --git a/tests/test_subprocess.py b/tests/test_subprocess.py
deleted file mode 100644
index bb291053..00000000
--- a/tests/test_subprocess.py
+++ /dev/null
@@ -1,142 +0,0 @@
-# test_subprocess.py
-
-import sys
-from curio import subprocess
-from curio import *
-import os
-import pytest
-import sys
-
-# ---- Test subprocesses and worker task related functions
-
-executable = sys.executable
-dirname = os.path.dirname(__file__)
-
-
-def test_simple(kernel):
-    results = []
-    async def subproc():
-        out = await subprocess.run([executable, os.path.join(dirname, 'child.py')], stdout=subprocess.PIPE)
-        results.append(out.stdout)
-        results.append(out.returncode)
-
-    kernel.run(subproc())
-    assert results == [
-        b't-minus 4\nt-minus 3\nt-minus 2\nt-minus 1\n'.replace(b'\n', os.linesep.encode('latin-1')),
-        0,
-    ]
-
-
-def test_simple_check_output(kernel):
-    results = []
-    async def subproc():
-        out = await subprocess.check_output([executable, os.path.join(dirname, 'child.py')])
-        results.append(out)
-
-    kernel.run(subproc())
-    assert results == [
-        b't-minus 4\nt-minus 3\nt-minus 2\nt-minus 1\n'.replace(b'\n', os.linesep.encode('latin-1')),
-    ]
-
-
-def test_bad_cmd(kernel):
-    results = []
-    async def subproc():
-        try:
-            out = await subprocess.run([executable, '-m', 'curio.test.bad'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
-            results.append('what?')
-        except subprocess.CalledProcessError:
-            results.append('bad command')
-
-    kernel.run(subproc())
-    assert results == ['bad command']
-
-
-def test_bad_cmd_check_output(kernel):
-    results = []
-    async def subproc():
-        try:
-            out = await subprocess.check_output([executable, '-m', 'curio.test.bad'], stderr=subprocess.STDOUT)
-            results.append('what?')
-        except subprocess.CalledProcessError:
-            results.append('bad command')
-
-    kernel.run(subproc())
-    assert results == ['bad command']
-
-
-def test_timeout(kernel):
-    results = []
-    async def subproc():
-        try:
-            async with timeout_after(0.5):
-                out = await subprocess.run([executable, os.path.join(dirname, 'child.py')], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
-                results.append('what?')
-        except TaskTimeout as e:
-            results.append('timeout')
-            results.append(e.stdout)
-            results.append(e.stderr)
-
-    kernel.run(subproc())
-    if sys.platform.startswith('win'):
-        assert results == ['timeout', b'', b'']
-    else:
-        assert results == ['timeout', b't-minus 4\n', b'']
-
-def test_universal():
-    with pytest.raises(RuntimeError):
-        p = subprocess.Popen([executable, '-m', 'bad'], universal_newlines=True)
-
-def test_stdin_pipe(kernel):
-    async def main():
-         p1 = subprocess.Popen([executable, os.path.join(dirname, 'child.py')], stdout=subprocess.PIPE)
-         p2 = subprocess.Popen([executable, os.path.join(dirname, 'ichild.py')], stdin=p1.stdout, stdout=subprocess.PIPE)
-         out = await p2.stdout.read()
-         assert out == b'4\n'.replace(b'\n', os.linesep.encode('latin-1'))
-
-    kernel.run(main())
-
-def test_check_output_stdin(kernel):
-    async def main():
-         out = await subprocess.check_output([executable, os.path.join(dirname, 'ichild.py')],
-                                             input=b'Line1\nLine2\nLine3\n')
-         assert out == b'3\n'.replace(b'\n', os.linesep.encode('latin-1'))
-
-    kernel.run(main())
-
-def test_no_input_cancel(kernel):
-    async def child():
-        p = subprocess.Popen([executable, os.path.join(dirname, 'child.py')], stdin=subprocess.PIPE)
-        try:
-            out = await p.communicate(input=b'x'*10000000)
-            assert False
-        except CancelledError as e:
-            assert e.stdout == b''
-            assert e.stderr == b''
-            raise
-
-    async def main():
-        t = await spawn(child)
-        await sleep(0.1)
-        await t.cancel()
-
-    kernel.run(main())
-
-def test_popen_join(kernel):
-    async def main():
-         p = subprocess.Popen([executable, '-c', 'import time;time.sleep(1)'])
-         code = await p.wait()
-         assert code == 0
-
-    kernel.run(main)
-
-def test_io_error(kernel):
-    async def main():
-         with pytest.raises(BrokenPipeError):
-             out = await subprocess.check_output([executable, '-c', 'import sys, time; sys.stdin.close(); time.sleep(1)'],
-                                           input=b'x'*10000000)
-
-    kernel.run(main)
-
-
-
diff --git a/tests/test_thread.py b/tests/test_thread.py
index e0773e3a..a5930d1f 100644
--- a/tests/test_thread.py
+++ b/tests/test_thread.py
@@ -170,23 +170,6 @@ async def main():
 
     kernel.run(main)
 
-import curio.subprocess as subprocess
-import sys
-
-@pytest.mark.skipif(sys.platform.startswith('win'),
-                    reason='Broken on windows')
-def test_subprocess_popen(kernel):
-    def func():
-        with subprocess.Popen([sys.executable, '-c', 'print("hello")'], stdout=subprocess.PIPE) as p:
-            data = AWAIT(p.stdout.read())
-            assert data == b'hello\n'
-
-    async def main():
-        t = await spawn_thread(func)
-        await t.join()
-
-    kernel.run(main)
-
 def test_task_group_thread(kernel):
     results = []
     async def add(x, y):
