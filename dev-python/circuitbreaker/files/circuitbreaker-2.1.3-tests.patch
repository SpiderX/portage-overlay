--- ../tests/test_functional.py	2025-10-15 00:12:18.659373516 +0300
+++ ../tests/test_functional.py	2025-10-15 00:13:15.421850811 +0300
@@ -48,6 +48,7 @@
         name="threshold_3",
     )(function)
 
+@pytest.mark.asyncio
 async def test_circuit_pass_through(
     resolve_call, circuit_success, function_call_return_value
 ):
@@ -61,6 +62,7 @@
     "circuit_threshold_2_timeout_1",
     "circuit_threshold_3_timeout_1",
 )
+@pytest.mark.asyncio
 async def test_circuitbreaker_monitor(
     resolve_call, circuit_failure, function_call_error
 ):
@@ -77,7 +79,7 @@
     assert len(list(CircuitBreakerMonitor.get_closed())) == 4
     assert len(list(CircuitBreakerMonitor.get_open())) == 1
 
-
+@pytest.mark.asyncio
 async def test_threshold_hit_prevents_consequent_calls(
     resolve_call, mock_function_call, circuit_threshold_1, function_call_error
 ):
@@ -95,7 +97,7 @@
 
     mock_function_call.assert_called_once_with()
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_recover_half_open(
     resolve_call, mock_function_call, circuit_threshold_3_timeout_1, sleep
 ):
@@ -167,7 +169,7 @@
     with pytest.raises(CircuitBreakerError):
         assert await resolve_call(circuit_threshold_3_timeout_1())
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_reopens_after_successful_calls(
     resolve_call, mock_function_call, circuit_threshold_2_timeout_1, sleep
 ):
--- ../tests/test_unit.py	2025-10-15 00:14:00.818290649 +0300
+++ ../tests/test_unit.py	2025-10-15 00:14:38.015683106 +0300
@@ -47,7 +47,7 @@
     assert str(error).startswith('Circuit "Foobar" OPEN until ')
     assert str(error).endswith('(0 failures, 30 sec remaining) (last_failure: Exception())')
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_wrapper_matches_function_type(function, is_async, is_generator):
     cb = CircuitBreaker(name='Foobar')
     wrapper = cb(function)
@@ -65,7 +65,7 @@
         == (is_async and is_generator)
     )
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_should_save_last_exception_on_failure_call(
     resolve_call, resolve_circuitbreaker_call_method, function, function_call_error
 ):
@@ -77,7 +77,7 @@
 
     assert isinstance(cb.last_failure, function_call_error)
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_should_clear_last_exception_on_success_call(
     resolve_call, resolve_circuitbreaker_call_method, function
 ):
@@ -90,7 +90,7 @@
 
     assert cb.last_failure is None
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_should_call_fallback_function_if_open(
     resolve_call, function, fallback_function, mock_fallback_call, fallback_call_return_value
 ):
@@ -102,7 +102,7 @@
     assert await resolve_call(decorated_func()) == fallback_call_return_value
     mock_fallback_call.assert_called_once_with()
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_should_not_call_function_if_open(
     resolve_call, function, mock_function_call, fallback_function, fallback_call_return_value
 ):
@@ -114,7 +114,7 @@
     assert await resolve_call(decorated_func()) == fallback_call_return_value
     assert not mock_function_call.called
 
-
+@pytest.mark.asyncio
 async def test_circuitbreaker_call_fallback_function_with_parameters(
     resolve_call, function, fallback_function, mock_fallback_call, fallback_call_return_value
 ):
