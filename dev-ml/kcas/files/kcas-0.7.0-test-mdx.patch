diff --git a/README.md b/README.md
index 5071b54..4ff5c86 100644
--- a/README.md
+++ b/README.md
@@ -116,9 +116,9 @@ one first creates shared memory locations:
 # let a = Loc.make 0
   and b = Loc.make 0
   and x = Loc.make 0
-val a : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
-val b : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
-val x : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val a : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val b : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val x : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
 ```
 
 One can then manipulate the locations individually:
@@ -302,7 +302,7 @@ transactions to `push` and `try_pop` elements:
 
 ```ocaml
 # let a_stack : int stack = stack ()
-val a_stack : int stack = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val a_stack : int stack = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
 
 # Xt.commit { tx = push a_stack 101 }
 - : unit = ()
@@ -421,8 +421,8 @@ transactions to `enqueue` and `try_dequeue` elements:
 ```ocaml
 # let a_queue : int queue = queue ()
 val a_queue : int queue =
-  {front = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
-   back = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}
+  {front = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
+   back = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}
 
 # Xt.commit { tx = enqueue a_queue 76 }
 - : unit = ()
@@ -537,12 +537,12 @@ To test them out, let's create a fresh stack and a queue
 
 ```ocaml
 # let a_stack : int stack = stack ()
-val a_stack : int stack = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val a_stack : int stack = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
 
 # let a_queue : int queue = queue ()
 val a_queue : int queue =
-  {front = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
-   back = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}
+  {front = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
+   back = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}
 ```
 
 and then spawn a domain that tries to atomically both pop and dequeue:
@@ -766,7 +766,7 @@ and create a leftist heap:
 ```ocaml
 # let a_heap : int leftist Loc.t = leftist ()
 val a_heap : int leftist Loc.t =
-  Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+  Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
 ```
 
 To populate the heap we need to define a transaction passing function and pass
@@ -1025,8 +1025,8 @@ We can then test that the cache works as expected:
 ```ocaml
 # let a_cache : (int, string) cache = cache 2
 val a_cache : (int, string) cache =
-  {space = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
-   table = <abstr>; order = <abstr>}
+  {space = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}; table = <abstr>;
+   order = <abstr>}
 
 # Xt.commit { tx = set_blocking a_cache 101 "basics" }
 - : unit = ()
@@ -1274,8 +1274,7 @@ Consider the following example of computing the size of a stack:
 
 ```ocaml
 # let a_stack = Loc.make [2; 3]
-val a_stack : int list Loc.t =
-  Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val a_stack : int list Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
 
 # let n_elems =
     let tx ~xt =
@@ -1442,8 +1441,7 @@ Using the Michael-Scott style queue is as easy as any other transactional queue:
 ```ocaml
 # let a_queue : int queue = queue ()
 val a_queue : int queue =
-  {head = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
-   tail = <abstr>}
+  {head = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}; tail = <abstr>}
 
 # Xt.commit { tx = enqueue a_queue 19 }
 - : unit = ()
@@ -1895,10 +1893,10 @@ for hash tables, we are ready to take it out for a spin:
 ```ocaml
 # let a_hashtbl : (string, int) hashtbl = hashtbl ()
 val a_hashtbl : (string, int) hashtbl =
-  {pending = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
+  {pending = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
    basic =
-    {size = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
-     data = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}}
+    {size = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
+     data = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}}
 
 # let assoc = [
     ("Intro", 101);
@@ -2014,8 +2012,8 @@ in the earlier example:
 ```ocaml
 # let a_queue : int queue = queue ()
 val a_queue : int queue =
-  {head = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
-   tail = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}
+  {head = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>};
+   tail = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}}
 
 # let counter = ref 1_000
 val counter : int ref = {contents = 1000}
@@ -2070,8 +2068,8 @@ locations. Let's just create two locations `a` and `b`:
 
 ```ocaml
 # let a = Loc.make 0 and b = Loc.make 0
-val a : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
-val b : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val a : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val b : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
 ```
 
 And create a helper that spawns a domain that repeatedly increments `a` and
diff --git a/doc/scheduler-interop.md b/doc/scheduler-interop.md
index 39bb662..a4af124 100644
--- a/doc/scheduler-interop.md
+++ b/doc/scheduler-interop.md
@@ -131,7 +131,7 @@ state in between, and then returns their sum:
 
 ```ocaml
 # let state = Loc.make 0
-val state : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+val state : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
 # let sync_to target =
     state
     |> Loc.get_as @@ fun current ->
diff --git a/src/kcas/kcas.mli b/src/kcas/kcas.mli
index 185a2c2..25bc274 100644
--- a/src/kcas/kcas.mli
+++ b/src/kcas/kcas.mli
@@ -47,9 +47,9 @@
       # let a = Loc.make 0
         and b = Loc.make 0
         and x = Loc.make 0
-      val a : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
-      val b : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
-      val x : int Loc.t = Kcas.Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+      val a : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+      val b : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
+      val x : int Loc.t = Loc.Loc {Kcas.Loc.state = <poly>; id = <poly>}
     ]}
 
     One can then manipulate the locations individually:
